%=$[$ 
 ' vim: ts=3:sw=3:syntax=golem
$][% @with args %]module     [$ process_name asprefix=\_ 
            $]d[% DIAGRAM %]h[% HELICITY %]l13
   ! file:      [% output.file %]
   ! generator: [% program.name %] ([% program.version %])
   use ninja_module, only: ki => ki_nin
   use [$ process_name asprefix=\_ $]util, only: cond, d => metric_tensor
   implicit none
   private

   complex(ki), parameter :: i_ = (0.0_ki, 1.0_ki)

   complex(ki), dimension(4), private :: vecA, vecB, vecC[$

@if extension qshift $][$
@else $]
   real(ki), dimension(4), private :: qshift[$
@end @if $]

   public :: numerator_t
contains[% 
@for brackets bracket="brack_%d" %][%
   @for brackets bracket="subbrack_%2$d_%1$d" %]
!---#[ function [% $_ %]:
   pure function [% $_ %](Q[$
      @select r2
      @case implicit explicit $], mu2[$
      @end @select $]) result(brack)
      use [$ process_name asprefix=\_ $]model
      use [$ process_name asprefix=\_ $]kinematics
      use [$ process_name asprefix=\_ $]color
      use [$ process_name asprefix=\_ $]abbrev[%
      @with args %][$
         @select abbrev.level
         @case diagram $]d[%DIAGRAM%]h[%HELICITY%][$
         @case group $]g[%GROUP%]h[%HELICITY%][$
         @case helicity $]h[%HELICITY%][$
         @end @select $][%
      @end @with %]
      implicit none
      complex(ki), dimension(4), intent(in) :: Q[$
      @select r2
      @case implicit explicit $]
      complex(ki), intent(in) :: mu2[$
      @end @select $]
      [% type.repr %] :: brack[% 
      @for symbols registers="t%d" %]
      [%    type.repr %] :: [% $_ %][%
      @end @for %][% 
      @for instructions prefix="inst." registers="t%d" %][%
         @select inst.$_ match="(.).*" format="%s"
         @case & %]
      brack[%
         @else %]
      [% inst.$_ %][%
         @end @select
      %] = [% expression match="\\$(\\d+)" format="t%s" %][%
      @end @for instructions %]
   end  function [% $_ %]
!---#] function [% $_ %]:[%
   @end @for innerbracket %]
!---#[ function [% $_ %]:
   pure function [% $_ %](Q[$
      @select r2
      @case implicit explicit $], mu2[$
      @end @select $]) result(brack)
      use [$ process_name asprefix=\_ $]model
      use [$ process_name asprefix=\_ $]kinematics
      use [$ process_name asprefix=\_ $]color
      use [$ process_name asprefix=\_ $]abbrev[%
      @with args %][$
         @select abbrev.level
         @case diagram $]d[%DIAGRAM%]h[%HELICITY%][$
         @case group $]g[%GROUP%]h[%HELICITY%][$
         @case helicity $]h[%HELICITY%][$
         @end @select $][%
      @end @with %]
      implicit none
      complex(ki), dimension(4), intent(in) :: Q[$
      @select r2
      @case implicit explicit $]
      complex(ki), intent(in) :: mu2[$
      @end @select $]
      [% type.repr %] :: brack[%
   @for symbols registers="t%d" %]
      [%    type.repr %] :: [% $_ %][%
   @end @for %][% 
   @for instructions prefix="inst." registers="t%d" %][%
      @select inst.$_ match="(.).*" format="%s"
      @case & %]
      brack[%
      @else %]
      [% inst.$_ %][%
      @end @select
      %] = [% expression bracket="brack_%2$d_%1$d(Q[$
      @select r2
      @case implicit $], mu2[$
      @end @select $])" %][%
   @end @for instructions %]
   end  function [% $_ %]
!---#] function [% $_ %]:[%
@end @for outerbracket %]
   
!---#[ subroutine numerator_t:
   subroutine numerator_t(ncut, mu2, a, b, c, deg, coeffs) &
   & bind(c, name="[% @with args %][$ process_name asprefix=\_ 
            $]d[% DIAGRAM %]h[% HELICITY %][% @end @with %]_ninja_t")
      use [$ process_name asprefix=\_ $]config, only: ki_nin => ki
      use [$ process_name asprefix=\_ $]globalsl1, only: epspow
      use [$ process_name asprefix=\_ $]kinematics
      use [$ process_name asprefix=\_ $]abbrev[%
      @with args %][$
         @select abbrev.level
         @case diagram $]d[%DIAGRAM%]h[%HELICITY%][$
         @case group $]g[%GROUP%]h[%HELICITY%][$
         @case helicity $]h[%HELICITY%][$
         @end @select $][%
      @end @with %]
      implicit none

      complex(ki_nin), dimension(4), parameter :: Q = (/ &
      & (0.0_ki_nin, 0.0_ki_nin), (0.0_ki_nin, 0.0_ki_nin), &
      & (0.0_ki_nin, 0.0_ki_nin), (0.0_ki_nin, 0.0_ki_nin)/)

      integer, intent(in) :: ncut, deg
      complex(ki_nin), intent(in) :: mu2
      complex(ki_nin), dimension(0:3), intent(in) :: a, b, c
      complex(ki_nin), dimension(0:*), intent(out) :: coeffs[%
      @for symbols registers="t%d" %]
      [%    type.repr %] :: [% $_ %][%
      @end @for %]

      vecA = a
      vecB = b
      vecC = c[%

   @with args %][$
      @if extension qshift $][$
      @else $][%
         @select QSHIFT
         @case 0 %]
      qshift(:) = 0.0_ki[%
         @else %]
      qshift = [% QSHIFT %][%
         @end @select %][$
      @end @if $][%
   @end @with %]
      if (deg.lt.0) return[%
   @for instructions registers="t%d" %][%
      @select $_ match="(.).*" format="%s"
      @case n %]
      coeffs([% $_ match="numerator_(\\d+)" format="%s" %]) = [%
               expression bracket="brack_%d[$
         @select r2
         @case only off $](Q)[$
         @end @select $]" %]
      if (deg.eq.[% $_ match="numerator_(\\d+)" format="%s" %]) return[%
      @else %]
      [% $_ %] = [% expression bracket="brack_%d[$
         @select r2
         @case only off $](Q)[$
         @end @select $]" %][%
      @end @select %][%
   @end @for instructions %]
   end subroutine numerator_t
!---#] subroutine numerator_t:
end module [$ process_name asprefix=\_
          $]d[%DIAGRAM%]h[%HELICITY%]l13[%
@end @with %]
